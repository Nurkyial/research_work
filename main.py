# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QComboBox, QWidget, QListWidget, QVBoxLayout, QHBoxLayout, QListWidgetItem, QScrollArea
from PyQt5.QtCore import Qt, QMimeData
from PyQt5.QtGui import QDrag
import pandas as pd
import copy
import docx
from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.section import WD_ORIENT
from docx.shared import Pt, Inches
from docx.oxml import OxmlElement
from docx.oxml.ns import qn



class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.upload_label = QtWidgets.QLabel(self.centralwidget)
        self.upload_label.setGeometry(QtCore.QRect(10, 20, 151, 51))
        font = QtGui.QFont()
        font.setPointSize(20)
        self.upload_label.setFont(font)
        self.upload_label.setObjectName("upload_label")
        self.text_label = QtWidgets.QLabel(self.centralwidget)
        self.text_label.setGeometry(QtCore.QRect(10, 80, 241, 31))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.text_label.setFont(font)
        self.text_label.setObjectName("text_label")

        self.file1 = QtWidgets.QLabel(self.centralwidget)
        self.file1.setGeometry(QtCore.QRect(10, 140, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.file1.setFont(font)
        self.file1.setObjectName("file1")

        self.file2 = QtWidgets.QLabel(self.centralwidget)
        self.file2.setGeometry(QtCore.QRect(10, 200, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.file2.setFont(font)
        self.file2.setObjectName("file2")

        # uploading file1
        self.browse1 = QtWidgets.QPushButton(self.centralwidget)
        self.browse1.setGeometry(QtCore.QRect(360, 140, 93, 28))
        self.browse1.setObjectName("browse1")
        self.browse1.clicked.connect(self.browse1_open)
        self.browse1.setToolTip("Add student's marks. It must be a docx file")

        # uploading file2
        self.browse2 = QtWidgets.QPushButton(self.centralwidget)
        self.browse2.setGeometry(QtCore.QRect(360, 200, 93, 28))
        self.browse2.setObjectName("browse2")
        self.browse2.clicked.connect(self.browse2_open)
        self.browse2.setToolTip("Add a study plan. It must be a xlsx file.")

        # match button for two files
        self.match = QtWidgets.QPushButton(self.centralwidget)
        self.match.setGeometry(QtCore.QRect(160, 400, 93, 28))
        self.match.setObjectName("match")
        self.match.setStyleSheet('QPushButton {background-color: #00bfff}')
        self.match.clicked.connect(self.match_button)
        self.match.setToolTip("Eliminate the academic difference.")

        # Initialize the file_path attribute
        self.file_path = None

        # test labels for browses
        self.test_label1 = QtWidgets.QLabel(self.centralwidget)
        self.test_label1.setGeometry(QtCore.QRect(60, 140, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.test_label1.setFont(font)
        self.test_label1.setObjectName("test_label")

        self.test_label2 = QtWidgets.QLabel(self.centralwidget)
        self.test_label2.setGeometry(QtCore.QRect(60, 200, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.test_label2.setFont(font)
        self.test_label2.setObjectName("test_label")


        self.sem = QtWidgets.QLabel(self.centralwidget)
        self.sem.setGeometry(QtCore.QRect(10, 290, 90, 30))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.sem.setFont(font)
        self.sem.setObjectName("semester")
        #self.sem.adjustSize()

        #  creating combobox for list of semesters
        self.comboBox = QComboBox(self.centralwidget)
        self.comboBox.setGeometry(QtCore.QRect(150, 290, 200, 50))
        self.comboBox.addItem("1")
        self.comboBox.addItem("2")
        self.comboBox.addItem("3")
        self.comboBox.addItem("4")
        self.comboBox.addItem("5")
        self.comboBox.addItem("6")
        self.comboBox.addItem("7")
        self.comboBox.addItem("8")

        MainWindow.setCentralWidget(self.centralwidget)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)


    def resize(self, text):
        max_word = 30
        return text[:max_word] + '...'


    def browse1_open(self):
        file, name = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "Open File", "", "All Files (*);; pdf files (*.pdf)")
        path = str(file)

        if name:
            self.test_label1.setText(self.resize(file))
            self.test_label1.adjustSize()
            # Update the file path attribute
            self.file_path1 = path


    def browse2_open(self):
        file, name = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "Open File", "", "All Files (*);; pdf files (*.pdf)")
        path = str(file)
        if name:
            self.test_label2.setText(self.resize(file))
            self.test_label2.adjustSize()
            self.file_path2 = path



    def match_button(self):
        # get the file path from the browse functions
        self.matching = Match()
        if (self.file_path1 and self.file_path2) is not None:
            complete_match, partially_match, mismatch_xls, mismatch_docx, complete_match_dct = [], [], [], [], []
            if self.file_path1.endswith('.docx') and self.file_path2.endswith('.xlsx'):
                self.docx = DocxReader(self, self.file_path1)
                self.docx_data = self.docx.read_docx()
                self.xls_data = XLSReader(self, self.file_path2)

                #print(self.matching)

                complete_match, partially_match, mismatch_xls, mismatch_docx, complete_match_dct = self.matching.match(self.docx_data, self.xls_data.excel_subjects)
                print(80*'-')
                print("Complete Match:", complete_match)
                print(80 * '-')
                print("Partially Match:", partially_match)
                print(80 * '-')
                print("Mismatch for excel file:", mismatch_xls)
                print(80 * '-')
                print("Mismatch for docx file:", mismatch_docx)

            elif self.file_path2.endswith('.docx') and self.file_path1.endswith('.xlsx'):
                self.docx_data = DocxReader(self, self.file_path2)
                self.xls_data = XLSReader(self, self.file_path1)


                complete_match, partially_match, mismatch_xls, mismatch_docx, complete_match_dct = self.matching.match(self.docx_data, self.xls_data.excel_subjects)
                print(80 * '-')
                print("Complete Match:", complete_match)
                print(80 * '-')
                print("Partially Match:", partially_match)
                print(80 * '-')
                print("Mismatch for excel file:", mismatch_xls)
                print(80 * '-')
                print("Mismatch for docx file:", mismatch_docx)

            else:
                print("Invalid file types. Please choose a DOCX and an Excel file.")
            self.resultsWindow = ResultsWindow(complete_match, partially_match, mismatch_xls, mismatch_docx, complete_match_dct)  # pass appropriate data
            self.resultsWindow.show()
        else:
            print("No file selected. Please choose a file")

        # Creating and displaying the results window


    # finding the current item in the combobox
    def find(self):
        self.content = self.comboBox.currentText()
        return int(self.content)


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.upload_label.setText(_translate("MainWindow", "Upload"))
        self.text_label.setText(_translate("MainWindow", "Upload two files (.pdf or .xls)"))
        self.test_label1.setText(_translate("MainWindow", ""))
        self.test_label2.setText(_translate("MainWindow", ""))
        self.file1.setText(_translate("MainWindow", "File1"))
        self.file2.setText(_translate("MainWindow", "File2"))
        self.browse1.setText(_translate("MainWindow", "Browse"))
        self.browse2.setText(_translate("MainWindow", "Browse"))
        self.match.setToolTip(_translate("MainWindow", "<html><head/><body><p>Match two files</p></body></html>"))
        self.match.setText(_translate("MainWindow", "Match"))
        self.sem.setText(_translate("MainWindow", "semester"))




class XLSReader:
    def __init__(self, ui_instance, file):
        self.ui_instance = ui_instance
        self.xls = pd.ExcelFile(file)
        self.course = 6 + self.ui_instance.find() / 2
        self.start = 5
        self.end = 50  # under question???
        self.excel_subjects = []
        self.save_to_dict(self.course, row_start=self.start, row_end=self.end)

    def save_to_dict(self, course, row_start=None, row_end=None):
        self.column = [(2, 11, 12, 21, 22)]
        cnt = 0
        if course == 6.5:
            self.column_indices = [(11, 12)]
            self.tcourse = int(course) + 1
            #print(self.tcourse, course)
        elif course - int(course) == 0.5:
            self.column_indices = [(11, 12), (21, 22)]
            self.tcourse = int(course) + 1
        else:
            self.tcourse = int(course)
            self.column_indices = [(11, 12), (21, 22)]


        # Iterate through each sheet
        for sheet_name in self.xls.sheet_names[6:self.tcourse]:
            # Read the sheet into a DataFrame
            self.df = pd.read_excel(self.xls, sheet_name)

            cnt += 1
            if cnt == self.tcourse - 6 and course - int(course) == 0.5:
                self.column_indices = [(11, 12)]

            for column_pair in self.column_indices:
                # Initialize a new dictionary for each semester
                data_dict = {}

                # Iterate over rows within the specified range and save it to the dictionary
                for index, row in self.df.iterrows():
                    if row_start is not None and index < row_start:
                        continue  # skip rows before the specified start index

                    if row_end is not None and index > row_end:
                        break

                    if pd.isna(row.iloc[2]):
                        break

                    key = row.iloc[2]
                    values = [row.iloc[column_pair[0]], row.iloc[column_pair[1]]]  # Use the rest as values

                    if pd.isna(key) or values[0] == 0:
                        continue

                    data_dict[key] = values

                if data_dict:
                    self.excel_subjects.append(data_dict)

        # Append the dictionary for this semester to the list
        #print(self.excel_subjects)
        return self.excel_subjects


class DocxReader:
    def __init__(self, ui_instance, docx_path):
        self.ui_instance = ui_instance
        self.docx_path = docx_path
        self.all_subjects = []
        self.semester = self.ui_instance.find()
        #self.read_docx(semester)

    def read_docx(self):
        cnt_s = 0

        # Open the Word document
        doc = docx.Document(self.docx_path)

        for table in doc.tables:
            sem_subjects = {}
            # Extract data from cells in the first row
            first_row = table.rows[0].cells[0]
            first_row_data = first_row.text
            sem = str(cnt_s + 1) + " " + "семестр"

            #print(first_row_data)

            # Checking if the semester we need is in the table
            if sem in first_row_data:
                cnt_s += 1
                # Find the column indices
                header_row = table.rows[1]
                date_column_index = None
                marks_column_index = None

                for i, cell in enumerate(header_row.cells):
                    if cell.text.strip().lower() == 'дата сдачи':
                        date_column_index = i
                    elif cell.text.strip().lower() == 'оценка (ects)':
                        marks_column_index = i

                for row in table.rows[2:]:
                    discipline = row.cells[0].text.strip()
                    if "диф. зачёт" in discipline:
                        control = "диф. З"
                        discipline1 = discipline.replace("(диф. зачёт)", '')
                    elif "зачёт" in discipline:
                        control = "З"
                        discipline1 = discipline.replace("(зачёт)", '')
                    elif "экзамен" in discipline:
                        control = "Э"
                        discipline1 = discipline.replace("(экзамен)", '')
                    elif "аттестация всех разделов" in discipline:
                        control = "аттестовано"
                        discipline1 = discipline.replace("(аттестация всех разделов)", '')
                    elif "РУП" in discipline:
                        continue
                    else:
                        control = ''
                        discipline1 = discipline

                    # Getting the date and marks using identified column indices
                    date = row.cells[date_column_index].text.strip() if date_column_index is not None else ''
                    marks = row.cells[marks_column_index].text.strip() if marks_column_index is not None else ''

                    # Create a dictionary
                    sem_subjects[discipline1.strip()] = (control, date, marks)

            if sem_subjects:
                self.all_subjects.append(sem_subjects)
            if cnt_s == self.semester:
                break

        return self.all_subjects



class Match:
    def __init__(self):
        self.complete_match = []
        self.partially_match = []
        self.mismatch_docx_lst = []
        self.mismatch_xlsx_lst = []
        self.complete_match_dct = {}
        self.partially_match_dct = {}
        self.mismatch_docx = {}
        self.mismatch_xlsx = {}
        # xls_data is a list which consists several dictionaries
        # docx_data is a list which consists several dictionaries


    def match(self, docx_data, xls_data):
        print("data from excel file: ", xls_data)
        print("data from docx file: ", docx_data)
        xls_data_copy = copy.deepcopy(xls_data)
        docx_data_copy = copy.deepcopy(docx_data)

        # Set to keep track of matched subjects with semester info
        matched_subjects = set()

        # first I get a first element of docx_data and compare it with every element in each semester from xlsx_data
        for docx_semester, docx_subjects in enumerate(docx_data):
            for docx_subject, docx_info in docx_subjects.items():
                #print(docx_subject)
                # iterate through every subject in xls_data
                for xls_semester, xls_subjects in enumerate(xls_data):
                    # a unique identifier for each subject including its semester
                    xls_subject_key = (docx_subject, xls_semester)
                    if xls_subject_key in matched_subjects:
                        continue  # Skip already matched subjects
                    if docx_subject in xls_subjects:
                        # If matched
                        matched_subjects.add(xls_subject_key)
                        xls_subject = docx_subject
                        # information about subjects
                        hours = xls_subjects[xls_subject][0]
                        kr_type_xls = xls_subjects[xls_subject][1]
                        kr_type_docx = docx_info[0]
                        mark = docx_data[docx_semester][docx_subject][1]
                        date = docx_data[docx_semester][docx_subject][2]

                        if docx_subject == xls_subject and kr_type_xls == kr_type_docx:
                            # add this subject to complete_match list
                            self.complete_match.append(docx_subject)
                            # adding this subject to the dictionary
                            self.complete_match_dct[docx_subject] = (hours, kr_type_xls, mark, date)

                        else:
                            self.partially_match.append((docx_subject, xls_subject))
                            # if they match partially, I add this subject to this dictionary
                            self.partially_match_dct[docx_subject] = (hours, kr_type_xls, kr_type_docx, mark, date)

                        # removing items from the copied dictionary
                        docx_data_copy[docx_semester].pop(docx_subject, None)
                        xls_data_copy[xls_semester].pop(xls_subject, None)
                        break

        # adding left subjects t0 mismatch dictionary
        for sem, subjects in enumerate(docx_data_copy):
            for key, value in subjects.items():
                self.mismatch_docx[key] = value
        for sem, subjects in enumerate(xls_data_copy):
            for key, value in subjects.items():
                self.mismatch_xlsx[key] = value
        return self.complete_match, self.partially_match_dct, xls_data_copy, docx_data_copy, self.complete_match_dct


class DraggableListWidget(QListWidget):
    def __init__(self,layout_group, parent=None):
        super(DraggableListWidget, self).__init__(parent)
        self.layout_group = layout_group
        self.currentlyDraggingItem = None
        self.setDragDropMode(QListWidget.DragDrop)
        self.setSelectionMode(QListWidget.SingleSelection)
        self.setAcceptDrops(True)
        self.setDragEnabled(True)

    def startDrag(self, supportedActions):
        drag = QDrag(self)
        mimeData = QMimeData()

        # Take the current item but do not remove it from the list yet
        item = self.takeItem(self.currentRow())
        if item:
            mimeData.setText(item.text())
            drag.setMimeData(mimeData)
            if drag.exec_(Qt.MoveAction) == Qt.MoveAction:
                # If the drag was successful, do not re-add the item
                pass
            else:
                # If the drag was not successful, add the item back to its original list
                self.insertItem(self.currentRow(), item)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dropEvent(self, event):
        source = event.source()
        if isinstance(source, DraggableListWidget) and source.layout_group == self.layout_group:
            # Proceed with the drop if the source and target are in the same layout group
            if event.source() != self and event.mimeData().hasText():
                # Get the dropped text and create a new list item
                text = event.mimeData().text()
                newItem = QListWidgetItem(text)

                # Find the drop position
                position = self.dropIndicatorPosition()
                if position == QListWidget.AboveItem:
                    row = self.row(self.itemAt(event.pos()))
                elif position == QListWidget.BelowItem:
                    row = self.row(self.itemAt(event.pos())) + 1
                else:
                    row = self.count()  # Add to the end of the list

                # Add the new item at the determined position
                self.insertItem(row, newItem)
                event.acceptProposedAction()
                # Remove the item from the source list if the source and target are different
                # if source != self:
                #     source.takeItem(source.row(self.currentlyDraggingItem))
        else:
            # Ignore the drop if they are from different layout groups
            event.ignore()




class ResultsWindow(QWidget):
    def __init__(self, complete_match, partially_match, mismatch_xls, mismatch_docx, complete_match_dct, parent=None):
        super(ResultsWindow, self).__init__(parent)
        # Layouts
        mainLayout = QHBoxLayout(self)
        leftLayout = QVBoxLayout()
        rightLayout = QVBoxLayout()

        self.complete_match = complete_match
        self.partially_match = partially_match
        self.mismatch_xls = mismatch_xls
        self.mismatch_docx = mismatch_docx
        self.complete_match_dct = complete_match_dct

        # List widgets
        self.completeMatchList_docx = DraggableListWidget('left')
        self.completeMatchList_xls = DraggableListWidget('right')
        self.partialMatchList_docx = DraggableListWidget('left')
        self.partialMatchList_xls = DraggableListWidget('right')
        self.mismatchList_docx = DraggableListWidget('left')
        self.mismatchList_xls = DraggableListWidget('right')

        #populate lists
        self.populateList(self.completeMatchList_docx, complete_match)
        self.populateList(self.completeMatchList_xls, complete_match)
        self.populateList(self.partialMatchList_docx, partially_match)
        self.populateList(self.partialMatchList_xls, partially_match)
        self.populateList(self.mismatchList_docx, mismatch_docx)
        self.populateList(self.mismatchList_xls, mismatch_xls)

        # background color
        # Create scroll areas with colors for each list and add them to the layouts
        self.addScrollArea(leftLayout, self.completeMatchList_docx, "green")
        self.addScrollArea(leftLayout, self.partialMatchList_docx, "yellow")
        self.addScrollArea(leftLayout, self.mismatchList_docx, "red")
        self.addScrollArea(rightLayout, self.completeMatchList_xls, "green")
        self.addScrollArea(rightLayout, self.partialMatchList_xls, "yellow")
        self.addScrollArea(rightLayout, self.mismatchList_xls, "red")

        listLayout = QHBoxLayout()
        mainLayout.addLayout(leftLayout)
        mainLayout.addLayout(rightLayout)

        mainLayout.addLayout(listLayout)

        # New button at the bottom
        self.newButton = QtWidgets.QPushButton("Generate documnent", self)
        self.newButton.setToolTip("Generate a new .docx file")
        self.newButton.setStyleSheet("QPushButton { background-color: #FF5733; color: white; }")

        #self.newButton.clicked.connect(self.ButtonClicked)
        self.newButton.clicked.connect(self.ButtonClicked)
        mainLayout.addWidget(self.newButton)  # Add the button to the main layout

        self.setLayout(mainLayout)

    def addScrollArea(self, layout, widget, color):
        scrollArea = QScrollArea(self)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        # Set a fixed size for the scroll area
        scrollArea.setFixedSize(500, 300)  # Example size: 300 width x 200 height
        scrollArea.setStyleSheet(f"background-color: {color};")
        layout.addWidget(scrollArea)

    def populateList(self, listWidget, items):
        if isinstance(items, list):
            for item in items:
                if isinstance(item, dict):
                    for subject in item:
                        list_item = QListWidgetItem(subject)
                        listWidget.addItem(list_item)
                else:
                    list_item = QListWidgetItem(item)
                    listWidget.addItem(list_item)
        elif isinstance(items, dict):
            for subject in items:
                list_item = QListWidgetItem(subject)
                listWidget.addItem(list_item)

    def updateDictionaries(self):
        updatedCompleteMatch = self.getListContents(self.completeMatchList_docx)
        updatedPartialMatch_docx = self.getListContents(self.partialMatchList_docx)
        updatedPartialMatch_xls = self.getListContents(self.partialMatchList_xls)
        updatedMismatch_docx = self.getListContents(self.mismatchList_docx)
        updatedMismatch_xls = self.getListContents(self.mismatchList_xls)

        # Updating dictionaries accordingly
        self.complete_match = updatedCompleteMatch
        # save all deleted subjects in here
        deleted_subjects = {}
        # updating complete_match dictionary
        complete_match_dct_copy = copy.deepcopy(self.complete_match_dct)
        for subject in self.complete_match_dct:
            if subject not in updatedCompleteMatch:
                complete_match_dct_copy.pop(subject, None)
                deleted_subjects[subject] = self.complete_match_dct[subject]

        # updating partially_match dictionaries
        partially_match_docx_copy = copy.deepcopy(self.partially_match)
        for subject in self.partially_match:
            if subject not in updatedPartialMatch_docx:
                partially_match_docx_copy.pop(subject, None)
                deleted_subjects[subject] = self.partially_match[subject]


        partially_match_xls_copy = copy.deepcopy(self.partially_match)
        for subject in self.partially_match:
            if subject not in updatedPartialMatch_xls:
                partially_match_xls_copy.pop(subject, None)
                deleted_subjects[subject] = self.partially_match[subject]

        # updating mismatch dictionaries
        mismatch_docx_copy = copy.deepcopy(self.mismatch_docx)
        for sem, subjects in enumerate(self.mismatch_docx):
            for subject in subjects:
                if subject not in updatedMismatch_docx:
                    mismatch_docx_copy[sem].pop(subject, None)
                    deleted_subjects[subject] = self.mismatch_docx[sem][subject]


        mismatch_xls_copy = copy.deepcopy(self.mismatch_xls)
        for sem, subjects in enumerate(self.mismatch_xls):
            for subject in subjects:
                if subject not in updatedMismatch_xls:
                    mismatch_xls_copy[sem].pop(subject, None)
                    deleted_subjects[subject] = self.mismatch_xls[sem][subject]



        # adding deleted subjects accordingly to list widget
        for subject in deleted_subjects:
            if subject in updatedCompleteMatch:
                complete_match_dct_copy[subject] = deleted_subjects[subject]
            elif subject in updatedPartialMatch_docx:
                partially_match_docx_copy[subject] = deleted_subjects[subject]
            elif subject in updatedPartialMatch_xls:
                partially_match_xls_copy[subject] = deleted_subjects[subject]
            elif subject in updatedMismatch_docx:
                mismatch_docx_copy[0][subject] = deleted_subjects[subject]
            elif subject in updatedMismatch_xls:
                mismatch_xls_copy[0][subject] = deleted_subjects[subject]


            # Print the updated dictionaries
        print(20 * "*")
        print("Updated Complete Match Dictionary:")
        print(complete_match_dct_copy)
        print("\nUpdated Partially Match Dictionary:")
        print(partially_match_docx_copy)
        print(partially_match_xls_copy)
        print("\nUpdated Mismatch Docx Dictionary:")
        print(mismatch_docx_copy)
        print("\nUpdated Mismatch Xls Dictionary:")
        print(mismatch_xls_copy)
        self.partially_match_xls, self.partially_match_docx, self.mismatch_xls, self.mismatch_docx = partially_match_xls_copy, partially_match_docx_copy, mismatch_xls_copy, mismatch_docx_copy

        #return partially_match_xls_copy, partially_match_docx_copy, mismatch_xls_copy, mismatch_docx_copy
    def getListContents(self, listWidget):
        items = []
        for index in range(listWidget.count()):
            items.append(listWidget.item(index).text())
        return items

    def ButtonClicked(self):
        # Call updateDictionaries when the button is clicked
        self.updateDictionaries()

        self.generateDocx()
        print("Dictionaries updated.")

    @staticmethod
    def set_cell_bold(cell):
        for paragraph in cell.paragraphs:
            for run in paragraph.runs:
                run.bold = True

    @staticmethod
    def set_cell_format(cell,bold=True, center=True):
        #cell.text = text
        for paragraph in cell.paragraphs:
            if center:
                paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
            if bold:
                run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()
                run.bold = True

    @staticmethod
    def set_vertical_alignment(cell, align="center"):  # align options: "top", "center", "bottom"
        try:
            tc = cell._tc
            tcPr = tc.get_or_add_tcPr()
            vAlign = OxmlElement('w:vAlign')
            vAlign.set(qn('w:val'), align)
            tcPr.append(vAlign)
        except Exception as e:
            print("Error in setting vertical alignment:", e)

    def create_table_structure(self, doc):
        # Create table
        table = doc.add_table(rows=2, cols=8)
        table.style = 'Table Grid'

        # Define and merge cells for headers
        headers = ['№',
                   'Название дисциплины из текущего РУПа',
                   'Объем текущего РУПа',
                   'З / Э/ ЗО',
                   'Семестр',
                   'Отметка о сдаче']

        merge_indices = [(0, 0, 1, 0), (0, 1, 1, 1), (0, 2, 0, 3),
                         (0, 4, 1, 4), (0, 5, 1, 5), (0, 6, 0, 7)]

        for header, indices in zip(headers, merge_indices):
            a = table.cell(*indices[0:2])
            b = table.cell(*indices[2:])
            merged_cell = a.merge(b)
            merged_cell.text = header

        hdr_cells = table.rows[1].cells
        hdr_cells[2].text = 'Зач.ед'
        hdr_cells[3].text = 'Часы'
        hdr_cells[6].text = 'оценка'
        hdr_cells[7].text = 'дата'

        column_index = [1, 2, 3, 4, 5, 6, 7]
        for row in table.rows[0, 2]:
            for column in column_index:
                cell = row.cells[column]
                self.set_cell_format(cell)


        return table

    def change_table(self, table):
        pass
    def generateDocx(self):
        doc = Document()
        section = doc.sections[0]
        section.orientation = WD_ORIENT.LANDSCAPE
        section.page_width = Inches(11.69)  # For A4 size
        section.page_height = Inches(8.27)

        # font style
        style = doc.styles['Normal']
        font = style.font
        font.name = 'Times New Roman'
        font.size = Pt(12)
        # adding the title
        p1 = doc.add_paragraph('«СОГЛАСОВАНО»')
        p1.runs[0].bold = True
        p1.alignment = WD_ALIGN_PARAGRAPH.RIGHT

        p2 = doc.add_paragraph('«_____» ___________ 20___')
        p2.alignment = WD_ALIGN_PARAGRAPH.RIGHT

        p3 = doc.add_paragraph('____________ / ______________')
        p3.alignment = WD_ALIGN_PARAGRAPH.RIGHT

        p4 = doc.add_paragraph('подпись      	ФИО  ')
        p4.runs[0].bold = True
        p4.alignment = WD_ALIGN_PARAGRAPH.RIGHT

        p5 = doc.add_paragraph('ПЛАН')
        p5.runs[0].bold = True
        p5.alignment = WD_ALIGN_PARAGRAPH.CENTER

        p6 = doc.add_paragraph('ликвидации академической разницы в связи с восстановлением')
        p6.alignment = WD_ALIGN_PARAGRAPH.CENTER

        p7 = doc.add_paragraph('в группу ______ НИЯУ МИФИ')
        p7.alignment = WD_ALIGN_PARAGRAPH.CENTER

        p8 = doc.add_paragraph('студента ___________________________')
        p8.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # p9 = doc.add_paragraph('Перезачесть дисциплины, изученные ранее и соответствующие учебному плану направления (09.03.04 «Программная инженерия»), в следующем объеме:')
        # p9.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # a title for the table
        title_paragraph = doc.add_paragraph('Перезачесть дисциплины, изученные ранее и соответствующие учебному плану направления (09.03.04 «Программная инженерия»), в следующем объеме:')
        #title_paragraph.style = doc.styles['Heading 1']  # Applying a heading style (optional)
        run = title_paragraph.runs[0]
        run.font.size = Pt(11)  # Setting font size
        # run.bold = True  # Making the title bold
        title_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT  # Center-aligning the title

        # Add a table for partially match
        table = doc.add_table(rows=2, cols=8)
        table.style = 'Table Grid'

        a = table.cell(0, 0)
        b = table.cell(1, 0)
        A = a.merge(b)
        A.text = '№'

        a1 = table.cell(0, 1)
        b1 = table.cell(1, 1)
        A1 = a1.merge(b1)
        A1.text = 'Название дисциплины из текущего РУПа /Название ранее сданной дисциплины'

        a2 = table.cell(0, 2)
        b2 = table.cell(0, 3)
        A2 = a2.merge(b2)
        A2.text = 'Объем текущего РУПа'

        a3 = table.cell(0, 4)
        b3 = table.cell(1, 4)
        A3 = a3.merge(b3)
        A3.text = 'З / Э/ ЗО'

        a4 = table.cell(0, 5)
        b4 = table.cell(1, 5)
        A4 = a4.merge(b4)
        A4.text = 'Семестр'

        a5 = table.cell(0, 6)
        b5 = table.cell(0, 7)
        A5 = a5.merge(b5)
        A5.text = 'Отметка о сдаче'

        hdr_cells = table.rows[1].cells
        hdr_cells[2].text = 'Зач.ед'
        hdr_cells[3].text = 'Часы'
        hdr_cells[6].text = 'оценка'
        hdr_cells[7].text = 'дата'

        self.set_cell_format(A)
        self.set_cell_format(A1)
        self.set_cell_format(A2)
        self.set_cell_format(A3)
        self.set_cell_format(A4)
        self.set_cell_format(A5)
        self.set_cell_format(hdr_cells[2])
        self.set_cell_format(hdr_cells[3])
        self.set_cell_format(hdr_cells[6])
        self.set_cell_format(hdr_cells[7])

        rows_to_modify = [0, 1]  # Specify the row indices you want to modify

        for row_index in rows_to_modify:
            row = table.rows[row_index]
            for cell in row.cells:
                # Apply your modifications (e.g., vertical alignment) to each cell
                self.set_vertical_alignment(cell, "center")



        #partially_match_xls, partially_match_docx, mismatch_xls, mismatch_docx = self.updateDictionaries()

        for index, subject in enumerate(self.partially_match_docx):
            row_cells = table.add_row().cells
            row_cells[0].text = str(index + 1)
            keys = list(self.partially_match_xls)
            row_cells[1].text = str(keys[index]) + '/' + subject
            if isinstance(self.partially_match_docx[subject][0], int):
                row_cells[2].text = str(int(int(self.partially_match_docx[subject][0]) / 36))
            else:
                row_cells[2].text = '5'

            if len(self.partially_match_docx[subject]) == 5:
                row_cells[3].text = str(self.partially_match_docx[subject][0])
                row_cells[4].text = self.partially_match_docx[subject][2]
                row_cells[5].text = '1'
                row_cells[6].text = self.partially_match_docx[subject][4]
                row_cells[7].text = self.partially_match_docx[subject][3]
            else:
                row_cells[3].text = '180'
                row_cells[4].text = self.partially_match_docx[subject][0]
                row_cells[5].text = '1'
                row_cells[6].text = self.partially_match_docx[subject][2]
                row_cells[7].text = self.partially_match_docx[subject][1]


            column_index = [1, 2, 3, 4, 5, 6, 7]

            # Start from the third row (index 2) and go through all the rows to make the font size 11
            for row in table.rows[2:]:
                for column in column_index:
                    cell = row.cells[column]
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.font.size = Pt(11)

            # making the rows to be aligned at the center
            for row in table.rows[2:]:
                for cell in row.cells:
                    # Apply your modifications (e.g., vertical alignment) to each cell
                    self.set_vertical_alignment(cell, "center")
                    self.set_cell_format(cell, bold=False)

        # a title for mismatch
        title_paragraph = doc.add_paragraph('Ликвидация академической задолженности, возникшей ввиду разницы'
                                            ' в учебных планах по следующим дисциплинам:')
        run = title_paragraph.runs[0]
        run.font.size = Pt(11)  # Setting font size
        # run.bold = True  # Making the title bold
        title_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT  # Center-aligning the title

        # a table for mismatch
        table2 = doc.add_table(rows=2, cols=8)
        table2.style = 'Table Grid'

        a = table2.cell(0, 0)
        b = table2.cell(1, 0)
        A = a.merge(b)
        A.text = '№'

        a1 = table2.cell(0, 1)
        b1 = table2.cell(1, 1)
        A1 = a1.merge(b1)
        A1.text = 'Название дисциплины из текущего РУПа'

        a2 = table2.cell(0, 2)
        b2 = table2.cell(0, 3)
        A2 = a2.merge(b2)
        A2.text = 'Объем текущего РУПа'

        a3 = table2.cell(0, 4)
        b3 = table2.cell(1, 4)
        A3 = a3.merge(b3)
        A3.text = 'З / Э/ ЗО'

        a4 = table2.cell(0, 5)
        b4 = table2.cell(1, 5)
        A4 = a4.merge(b4)
        A4.text = 'Семестр'

        a5 = table2.cell(0, 6)
        b5 = table2.cell(0, 7)
        A5 = a5.merge(b5)
        A5.text = 'Отметка о сдаче'

        hdr_cells = table2.rows[1].cells
        hdr_cells[2].text = 'Зач.ед'
        hdr_cells[3].text = 'Часы'
        hdr_cells[6].text = 'оценка'
        hdr_cells[7].text = 'дата'

        self.set_cell_format(A)
        self.set_cell_format(A1)
        self.set_cell_format(A2)
        self.set_cell_format(A3)
        self.set_cell_format(A4)
        self.set_cell_format(A5)
        self.set_cell_format(hdr_cells[2])
        self.set_cell_format(hdr_cells[3])
        self.set_cell_format(hdr_cells[6])
        self.set_cell_format(hdr_cells[7])

        rows_to_modify = [0, 1]  # Specify the row indices you want to modify

        for row_index in rows_to_modify:
            row = table2.rows[row_index]
            for cell in row.cells:
                # Apply your modifications (e.g., vertical alignment) to each cell
                self.set_vertical_alignment(cell, "center")

        for index, subjects in enumerate(self.mismatch_xls):
            for subject in subjects:
                row_cells = table2.add_row().cells
                row_cells[0].text = str(index + 1)
                row_cells[1].text = subject
                row_cells[2].text = str(int(int(subjects[subject][0]) / 36))
                #row_cells[2].text = str(int(int(subjects[subject][0]) / 36))
                row_cells[3].text = str(subjects[subject][0])
                row_cells[4].text = subjects[subject][1]
                row_cells[5].text = str(index)


        column_index = [1, 2, 3, 4, 5, 6, 7]

        # Start from the third row (index 2) and go through all the rows to make the font size 11
        for row in table2.rows[2:]:
            for column in column_index:
                cell = row.cells[column]
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(11)

        # making the rows to be aligned at the center
        for row in table2.rows[2:]:
            for cell in row.cells:
                # Apply your modifications (e.g., vertical alignment) to each cell
                self.set_vertical_alignment(cell, "center")
                self.set_cell_format(cell, bold=False)


        # 3rd table
        table3 = doc.add_table(rows=2, cols=2)
        column_index = [0, 1]
        a = 'СТУДЕНТ ГРУППЫ:     ___________ /____________ \n' \
            '                                    подпись	  ФИО   \n' \
            'Контактный телефон: \n' \
            'E-mail: \n'

        b = 'ПРИНЯТО В РАБОТУ: \n' \
            '' \
            'Зам. начальника УО    ____________ /__________\n ' \
            '                                        подпись	     ФИО   \n'

        c = 'СОСТАВИЛ: \n ' \
            'Зам. зав. каф. №22   __________ / А.Ю. Никифоров \n' \
            '                                       подпись	      	  ФИО'

        d = 'СОГЛАСОВАНО: \n' \
            'Зам. директора ИОПП   ___________ /_Д.А. Самарченко_ \n' \
            '                                        подпись	        ФИО '

        lst = [a, b, c, d]
        cnt = 0
        for row in table3.rows:
            for column in column_index:
                cell = row.cells[column]
                cell.text = lst[cnt]
                cnt += 1



        # Save the document
        doc.save('example.docx')



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    app.setStyle(QtWidgets.QStyleFactory.create('Fusion'))
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)

    MainWindow.show()
    sys.exit(app.exec_())
