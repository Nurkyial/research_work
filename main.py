# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QComboBox,QWidget, QListWidget, QVBoxLayout, QHBoxLayout, QListWidgetItem, QScrollArea
from PyQt5.QtCore import Qt, QMimeData
from PyQt5.QtGui import QDrag
import pandas as pd
import docx
import copy

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.upload_label = QtWidgets.QLabel(self.centralwidget)
        self.upload_label.setGeometry(QtCore.QRect(10, 20, 151, 51))
        font = QtGui.QFont()
        font.setPointSize(20)
        self.upload_label.setFont(font)
        self.upload_label.setObjectName("upload_label")
        self.text_label = QtWidgets.QLabel(self.centralwidget)
        self.text_label.setGeometry(QtCore.QRect(10, 80, 241, 31))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.text_label.setFont(font)
        self.text_label.setObjectName("text_label")

        self.file1 = QtWidgets.QLabel(self.centralwidget)
        self.file1.setGeometry(QtCore.QRect(10, 140, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.file1.setFont(font)
        self.file1.setObjectName("file1")

        self.file2 = QtWidgets.QLabel(self.centralwidget)
        self.file2.setGeometry(QtCore.QRect(10, 200, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.file2.setFont(font)
        self.file2.setObjectName("file2")

        # uploading file1
        self.browse1 = QtWidgets.QPushButton(self.centralwidget)
        self.browse1.setGeometry(QtCore.QRect(360, 140, 93, 28))
        self.browse1.setObjectName("browse1")
        self.browse1.clicked.connect(self.browse1_open)
        self.browse1.setToolTip("Add student's marks. It must be a docx file")

        # uploading file2
        self.browse2 = QtWidgets.QPushButton(self.centralwidget)
        self.browse2.setGeometry(QtCore.QRect(360, 200, 93, 28))
        self.browse2.setObjectName("browse2")
        self.browse2.clicked.connect(self.browse2_open)
        self.browse2.setToolTip("Add a study plan. It must be a xlsx file.")

        # match button for two files
        self.match = QtWidgets.QPushButton(self.centralwidget)
        self.match.setGeometry(QtCore.QRect(160, 400, 93, 28))
        self.match.setObjectName("match")
        self.match.setStyleSheet('QPushButton {background-color: #00bfff}')
        self.match.clicked.connect(self.match_button)
        self.match.setToolTip("Eliminate the academic difference.")

        # Initialize the file_path attribute
        self.file_path = None

        # test labels for browses
        self.test_label1 = QtWidgets.QLabel(self.centralwidget)
        self.test_label1.setGeometry(QtCore.QRect(60, 140, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.test_label1.setFont(font)
        self.test_label1.setObjectName("test_label")

        self.test_label2 = QtWidgets.QLabel(self.centralwidget)
        self.test_label2.setGeometry(QtCore.QRect(60, 200, 55, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.test_label2.setFont(font)
        self.test_label2.setObjectName("test_label")


        self.sem = QtWidgets.QLabel(self.centralwidget)
        self.sem.setGeometry(QtCore.QRect(10, 290, 90, 30))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.sem.setFont(font)
        self.sem.setObjectName("semester")
        #self.sem.adjustSize()

        #  creating combobox for list of semesters
        self.comboBox = QComboBox(self.centralwidget)
        self.comboBox.setGeometry(QtCore.QRect(150, 290, 200, 50))
        self.comboBox.addItem("1")
        self.comboBox.addItem("2")
        self.comboBox.addItem("3")
        self.comboBox.addItem("4")
        self.comboBox.addItem("5")
        self.comboBox.addItem("6")
        self.comboBox.addItem("7")
        self.comboBox.addItem("8")

        MainWindow.setCentralWidget(self.centralwidget)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)


    def resize(self, text):
        max_word = 30
        return text[:max_word] + '...'


    def browse1_open(self):
        file, name = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "Open File", "", "All Files (*);; pdf files (*.pdf)")
        path = str(file)

        if name:
            self.test_label1.setText(self.resize(file))
            self.test_label1.adjustSize()
            # Update the file path attribute
            self.file_path1 = path


    def browse2_open(self):
        file, name = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, "Open File", "", "All Files (*);; pdf files (*.pdf)")
        path = str(file)
        if name:
            self.test_label2.setText(self.resize(file))
            self.test_label2.adjustSize()
            self.file_path2 = path



    def match_button(self):
        # get the file path from the browse functions
        self.matching = Match()
        if (self.file_path1 and self.file_path2) is not None:
            complete_match, partially_match, mismatch_xls, mismatch_docx = [], [], [], []
            if self.file_path1.endswith('.docx') and self.file_path2.endswith('.xlsx'):
                self.docx = DocxReader(self, self.file_path1)
                self.docx_data = self.docx.read_docx()
                self.xls_data = XLSReader(self, self.file_path2)

                #print(self.matching)

                complete_match, partially_match, mismatch_xls, mismatch_docx = self.matching.match(self.docx_data, self.xls_data.excel_subjects)
                print(80*'-')
                print("Complete Match:", complete_match)
                print(80 * '-')
                print("Partially Match:", partially_match)
                print(80 * '-')
                print("Mismatch for excel file:", mismatch_xls)
                print(80 * '-')
                print("Mismatch for docx file:", mismatch_docx)

            elif self.file_path2.endswith('.docx') and self.file_path1.endswith('.xlsx'):
                self.docx_data = DocxReader(self, self.file_path2)
                self.xls_data = XLSReader(self, self.file_path1)


                complete_match, partially_match, mismatch_xls, mismatch_docx = self.matching.match(self.docx_data, self.xls_data.excel_subjects)
                print(80 * '-')
                print("Complete Match:", complete_match)
                print(80 * '-')
                print("Partially Match:", partially_match)
                print(80 * '-')
                print("Mismatch for excel file:", mismatch_xls)
                print(80 * '-')
                print("Mismatch for docx file:", mismatch_docx)

            else:
                print("Invalid file types. Please choose a DOCX and an Excel file.")
            self.resultsWindow = ResultsWindow(complete_match, partially_match, mismatch_xls, mismatch_docx)  # pass appropriate data
            self.resultsWindow.show()
        else:
            print("No file selected. Please choose a file")

        # Creating and displaying the results window


    # finding the current item in the combobox
    def find(self):
        self.content = self.comboBox.currentText()
        return int(self.content)


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.upload_label.setText(_translate("MainWindow", "Upload"))
        self.text_label.setText(_translate("MainWindow", "Upload two files (.pdf or .xls)"))
        self.test_label1.setText(_translate("MainWindow", ""))
        self.test_label2.setText(_translate("MainWindow", ""))
        self.file1.setText(_translate("MainWindow", "File1"))
        self.file2.setText(_translate("MainWindow", "File2"))
        self.browse1.setText(_translate("MainWindow", "Browse"))
        self.browse2.setText(_translate("MainWindow", "Browse"))
        self.match.setToolTip(_translate("MainWindow", "<html><head/><body><p>Match two files</p></body></html>"))
        self.match.setText(_translate("MainWindow", "Match"))
        self.sem.setText(_translate("MainWindow", "semester"))




class XLSReader:
    def __init__(self, ui_instance, file):
        self.ui_instance = ui_instance
        self.xls = pd.ExcelFile(file)
        self.course = 6 + self.ui_instance.find() / 2
        self.start = 5
        self.end = 50  # under question???
        self.excel_subjects = []
        self.save_to_dict(self.course, row_start=self.start, row_end=self.end)

    def save_to_dict(self, course, row_start=None, row_end=None):
        self.column = [(2, 11, 12, 21, 22)]
        cnt = 0
        if course == 6.5:
            self.column_indices = [(11, 12)]
            self.tcourse = int(course) + 1
            #print(self.tcourse, course)
        elif course - int(course) == 0.5:
            self.column_indices = [(11, 12), (21, 22)]
            self.tcourse = int(course) + 1
        else:
            self.tcourse = int(course)
            self.column_indices = [(11, 12), (21, 22)]


        # Iterate through each sheet
        for sheet_name in self.xls.sheet_names[6:self.tcourse]:
            # Read the sheet into a DataFrame
            self.df = pd.read_excel(self.xls, sheet_name)

            cnt += 1
            if cnt == self.tcourse - 6 and course - int(course) == 0.5:
                self.column_indices = [(11, 12)]

            for column_pair in self.column_indices:
                # Initialize a new dictionary for each semester
                data_dict = {}

                # Iterate over rows within the specified range and save it to the dictionary
                for index, row in self.df.iterrows():
                    if row_start is not None and index < row_start:
                        continue  # skip rows before the specified start index

                    if row_end is not None and index > row_end:
                        break

                    if pd.isna(row.iloc[2]):
                        break

                    key = row.iloc[2]
                    values = [row.iloc[column_pair[0]], row.iloc[column_pair[1]]]  # Use the rest as values

                    if pd.isna(key) or values[0] == 0:
                        continue

                    data_dict[key] = values

                if data_dict:
                    self.excel_subjects.append(data_dict)

        # Append the dictionary for this semester to the list
        #print(self.excel_subjects)
        return self.excel_subjects


class DocxReader:
    def __init__(self, ui_instance, docx_path):
        self.ui_instance = ui_instance
        self.docx_path = docx_path
        self.all_subjects = []
        self.semester = self.ui_instance.find()
        #self.read_docx(semester)

    def read_docx(self):
        cnt_s = 0

        # Open the Word document
        doc = docx.Document(self.docx_path)

        for table in doc.tables:
            sem_subjects = {}
            # Extract data from cells in the first row
            first_row = table.rows[0].cells[0]
            first_row_data = first_row.text
            sem = str(cnt_s + 1) + " " + "семестр"

            #print(first_row_data)

            # Checking if the semester we need is in the table
            if sem in first_row_data:
                cnt_s += 1
                # Find the column indices
                header_row = table.rows[1]
                date_column_index = None
                marks_column_index = None

                for i, cell in enumerate(header_row.cells):
                    if cell.text.strip().lower() == 'дата сдачи':
                        date_column_index = i
                    elif cell.text.strip().lower() == 'оценка (ects)':
                        marks_column_index = i

                for row in table.rows[2:]:
                    discipline = row.cells[0].text.strip()
                    if "диф. зачёт" in discipline:
                        control = "диф. З"
                        discipline1 = discipline.replace("(диф. зачёт)", '')
                    elif "зачёт" in discipline:
                        control = "З"
                        discipline1 = discipline.replace("(зачёт)", '')
                    elif "экзамен" in discipline:
                        control = "Э"
                        discipline1 = discipline.replace("(экзамен)", '')
                    elif "аттестация всех разделов" in discipline:
                        control = "аттестовано"
                        discipline1 = discipline.replace("(аттестация всех разделов)", '')
                    elif "РУП" in discipline:
                        continue
                    else:
                        control = ''
                        discipline1 = discipline

                    # Getting the date and marks using identified column indices
                    date = row.cells[date_column_index].text.strip() if date_column_index is not None else ''
                    marks = row.cells[marks_column_index].text.strip() if marks_column_index is not None else ''

                    # Create a dictionary
                    sem_subjects[discipline1.strip()] = (control, date, marks)

            if sem_subjects:
                self.all_subjects.append(sem_subjects)
            if cnt_s == self.semester:
                break

        return self.all_subjects



class Match:
    def __init__(self):
        self.complete_match = []
        self.partially_match = []
        self.mismatch_docx_lst = []
        self.mismatch_xlsx_lst = []
        self.complete_match_dct = {}
        self.partially_match_dct = {}
        self.mismatch_docx = {}
        self.mismatch_xlsx = {}
        # xls_data is a list which consists several dictionaries
        # docx_data is a list which consists several dictionaries


    def match(self, docx_data, xls_data):
        print("data from excel file: ", xls_data)
        print("data from docx file: ", docx_data)
        xls_data_copy = copy.deepcopy(xls_data)
        docx_data_copy = copy.deepcopy(docx_data)

        # Set to keep track of matched subjects with semester info
        matched_subjects = set()

        # first I get a first element of docx_data and compare it with every element in each semester from xlsx_data
        for docx_semester, docx_subjects in enumerate(docx_data):
            for docx_subject, docx_info in docx_subjects.items():
                #print(docx_subject)
                # iterate through every subject in xls_data
                for xls_semester, xls_subjects in enumerate(xls_data):
                    # a unique identifier for each subject including its semester
                    xls_subject_key = (docx_subject, xls_semester)
                    if xls_subject_key in matched_subjects:
                        continue  # Skip already matched subjects
                    if docx_subject in xls_subjects:
                        # If matched
                        matched_subjects.add(xls_subject_key)
                        xls_subject = docx_subject
                        # information about subjects
                        hours = xls_subjects[xls_subject][0]
                        kr_type_xls = xls_subjects[xls_subject][1]
                        kr_type_docx = docx_info[0]
                        mark = docx_data[docx_semester][docx_subject][1]
                        date = docx_data[docx_semester][docx_subject][2]

                        if docx_subject == xls_subject and kr_type_xls == kr_type_docx:
                            # add this subject to complete_match list
                            self.complete_match.append(docx_subject)
                            # adding this subject to the dictionary
                            self.complete_match_dct[docx_subject] = (hours, kr_type_xls, mark, date)

                        else:
                            self.partially_match.append((docx_subject, xls_subject))
                            # if they match partially, I add this subject to this dictionary
                            self.partially_match_dct[docx_subject] = (hours, kr_type_xls, kr_type_docx, mark, date)

                        # removing items from the copied dictionary
                        docx_data_copy[docx_semester].pop(docx_subject, None)
                        xls_data_copy[xls_semester].pop(xls_subject, None)
                        break

        # adding left subjects t0 mismatch dictionary
        for sem, subjects in enumerate(docx_data_copy):
            for key, value in subjects.items():
                self.mismatch_docx[key] = value
        for sem, subjects in enumerate(xls_data_copy):
            for key, value in subjects.items():
                self.mismatch_xlsx[key] = value
        return self.complete_match, self.partially_match_dct, xls_data_copy, docx_data_copy


class DraggableListWidget(QListWidget):
    def __init__(self,layout_group, parent=None):
        super(DraggableListWidget, self).__init__(parent)
        self.layout_group = layout_group
        self.currentlyDraggingItem = None
        self.setDragDropMode(QListWidget.DragDrop)
        self.setSelectionMode(QListWidget.SingleSelection)
        self.setAcceptDrops(True)
        self.setDragEnabled(True)

    def startDrag(self, supportedActions):
        drag = QDrag(self)
        mimeData = QMimeData()

        # Take the current item but do not remove it from the list yet
        item = self.takeItem(self.currentRow())
        if item:
            mimeData.setText(item.text())
            drag.setMimeData(mimeData)
            if drag.exec_(Qt.MoveAction) == Qt.MoveAction:
                # If the drag was successful, do not re-add the item
                pass
            else:
                # If the drag was not successful, add the item back to its original list
                self.insertItem(self.currentRow(), item)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dropEvent(self, event):
        source = event.source()
        if isinstance(source, DraggableListWidget) and source.layout_group == self.layout_group:
            # Proceed with the drop if the source and target are in the same layout group
            if event.source() != self and event.mimeData().hasText():
                # Get the dropped text and create a new list item
                text = event.mimeData().text()
                newItem = QListWidgetItem(text)

                # Find the drop position
                position = self.dropIndicatorPosition()
                if position == QListWidget.AboveItem:
                    row = self.row(self.itemAt(event.pos()))
                elif position == QListWidget.BelowItem:
                    row = self.row(self.itemAt(event.pos())) + 1
                else:
                    row = self.count()  # Add to the end of the list

                # Add the new item at the determined position
                self.insertItem(row, newItem)
                event.acceptProposedAction()
                # Remove the item from the source list if the source and target are different
                # if source != self:
                #     source.takeItem(source.row(self.currentlyDraggingItem))
        else:
            # Ignore the drop if they are from different layout groups
            event.ignore()



class ResultsWindow(QWidget):
    def __init__(self, complete_match, partially_match, mismatch_xls, mismatch_docx, parent=None):
        super(ResultsWindow, self).__init__(parent)
        # Layouts
        mainLayout = QHBoxLayout(self)
        leftLayout = QVBoxLayout()
        rightLayout = QVBoxLayout()

        # List widgets
        self.completeMatchList_docx = DraggableListWidget('left')
        self.completeMatchList_xls = DraggableListWidget('right')
        self.partialMatchList_docx = DraggableListWidget('left')
        self.partialMatchList_xls = DraggableListWidget('right')
        self.mismatchList_docx = DraggableListWidget('left')
        self.mismatchList_xls = DraggableListWidget('right')

        #populate lists
        self.populateList(self.completeMatchList_docx, complete_match)
        self.populateList(self.completeMatchList_xls, complete_match)
        self.populateList(self.partialMatchList_docx, partially_match)
        self.populateList(self.partialMatchList_xls, partially_match)
        self.populateList(self.mismatchList_docx, mismatch_docx)
        self.populateList(self.mismatchList_xls, mismatch_xls)

        # background color
        # Create scroll areas with colors for each list and add them to the layouts
        self.addScrollArea(leftLayout, self.completeMatchList_docx, "green")
        self.addScrollArea(leftLayout, self.partialMatchList_docx, "yellow")
        self.addScrollArea(leftLayout, self.mismatchList_docx, "red")
        self.addScrollArea(rightLayout, self.completeMatchList_xls, "green")
        self.addScrollArea(rightLayout, self.partialMatchList_xls, "yellow")
        self.addScrollArea(rightLayout, self.mismatchList_xls, "red")

        listLayout = QHBoxLayout()
        mainLayout.addLayout(leftLayout)
        mainLayout.addLayout(rightLayout)

        mainLayout.addLayout(listLayout)

        # New button at the bottom
        self.newButton = QtWidgets.QPushButton("Generate documnent", self)
        self.newButton.setToolTip("Generate a new .docx file")
        self.newButton.setStyleSheet("QPushButton { background-color: #FF5733; color: white; }")
        mainLayout.addWidget(self.newButton)  # Add the button to the main layout

        self.setLayout(mainLayout)

    def addScrollArea(self, layout, widget, color):
        scrollArea = QScrollArea(self)
        scrollArea.setWidgetResizable(True)
        scrollArea.setWidget(widget)
        # Set a fixed size for the scroll area
        scrollArea.setFixedSize(500, 300)  # Example size: 300 width x 200 height
        scrollArea.setStyleSheet(f"background-color: {color};")
        layout.addWidget(scrollArea)

    def populateList(self, listWidget, items):
        if isinstance(items, list):
            for item in items:
                if isinstance(item, dict):
                    for subject in item:
                        list_item = QListWidgetItem(subject)
                        listWidget.addItem(list_item)
                else:
                    list_item = QListWidgetItem(item)
                    listWidget.addItem(list_item)
        elif isinstance(items, dict):
            for subject in items:
                list_item = QListWidgetItem(subject)
                listWidget.addItem(list_item)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    app.setStyle(QtWidgets.QStyleFactory.create('Fusion'))
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)

    MainWindow.show()
    sys.exit(app.exec_())
